package Sort;

import java.lang.reflect.Array;
import java.util.ArrayList;

import Exceptions.EmptyArrayException;
import Exceptions.OutOfBoundException;


public class MergeHybridSort <T extends Comparable<T>> extends Sort<T> {
	
	
	
	/**
	 * 
	 * Constructor With Generic Array Parameter
	 * Sorts The Whole Array
	 * 
	 * @param Array Array To Sort
	 * @throws EmptyArrayException 
	 * @throws OutOfBoundException 
	 * 
	 */
	public MergeHybridSort(T[] Array) throws EmptyArrayException, OutOfBoundException {
		
		this(Array, 0, Array.length-1);
		
	}
	
	

	/**
	 * 
	 * Constructor With Generic Array Parameter
	 * 
	 * @param Array Array To Sort
	 * @throws EmptyArrayException 
	 * @throws OutOfBoundException 
	 * 
	 */
	public MergeHybridSort(T[] Array, int leftBound, int rightBound) throws EmptyArrayException, OutOfBoundException {
		
		super(Array);
		
		this.exceptionOutOfBoundThrower (leftBound, rightBound);
		
		if ((rightBound - leftBound) != 0) { // One Element => Already Sorted
			
			this.mergeHybridSort (leftBound, rightBound);	
			
		}	
		
	}
	
	
	
	/**
	 * 
	 * Constructor With Generic ArrayList Parameter
	 * Sorts The Whole ArrayList
	 * 
	 * @param ArrayList ArrayList To Sort
	 * @throws EmptyArrayException 
	 * @throws OutOfBoundException 
	 * 
	 */
	public MergeHybridSort(ArrayList<T> ArrayList) throws EmptyArrayException, OutOfBoundException {
		
		this(ArrayList, 0, ArrayList.size());
		
	}
	
	
	
	/**
	 * 
	 * Constructor With Generic ArrayList Parameter
	 * 
	 * @param ArrayList ArrayList To Sort
	 * @throws EmptyArrayException 
	 * @throws OutOfBoundException 
	 * 
	 */
	public MergeHybridSort(ArrayList<T> ArrayList, int leftBound, int rightBound) throws EmptyArrayException, OutOfBoundException {
		
		super(ArrayList);
		
		this.exceptionOutOfBoundThrower (leftBound, rightBound);
		
		if ((rightBound - leftBound) != 0) { // One Element => Already Sorted
		
			this.mergeHybridSort(leftBound, rightBound);	
			
		}
		
	}
	
	
	
	/** 
	 * MergeSort Hybrid Implementation:
	 * 
	 * <p><pre>
	 * Worst Case: O(nlogn)
	 * Average Case: O(nlogn)
	 * Best Case: O(nlogn)
	 * </pre><p>
	 * 
	 * The Algorithms Works By Splicing The Input In Two And Calling Recursively
	 * MergeSort On The Two Lists. If The List Has Only One Elements Stops The
	 * Recursion, Otherwise Calls The Merge Function On The Two Sublists,
	 * That Fuses The Two Ordered Lists Into A Single Ordered One.
	 * 
	 * @param leftBound Left Limit For The Range Of Array's Values To Sort
	 * @param rightBound Right Limit For The Range Of Array's Values To Sort
	 * 
	 * 
	 */
	private void mergeHybridSort (int leftBound, int rightBound) {
		
		if ((rightBound - leftBound) == 0) { // One Element, Already Sorted
			
			return;
			
		} else {
			
			if ((rightBound - leftBound) <= 50) {
				
				this.insertionSort(leftBound, rightBound);
				
			} else {
			
				int center =(int) ((leftBound + rightBound)/2);
			
				this.mergeHybridSort(leftBound, center);
			
				this.mergeHybridSort(center+1, rightBound);
			
				this.merge(leftBound, center, rightBound);
				
			}
			
		}
		
	}

	
	
	/**
	 * 
	 * Merge function To Fuse Two Lists Generated By MergeSort
	 * 
	 * @param leftBound Left Limit For The Range Of Array's Values To Sort
	 * @param center center that separate the two lists
	 * @param rightBound right limit
	 * 
	 */
	private void merge (int leftBound, int center, int rightBound) {
		
		// Create Left Array
		@SuppressWarnings("unchecked")
		T[] L = (T[]) Array.newInstance(this.arraySort[0].getClass(), (center - leftBound + 1));
		
		// Create Right Array
		@SuppressWarnings("unchecked")
		T[] R = (T[]) Array.newInstance(this.arraySort[0].getClass(), (rightBound - center));
		
		// Fill Left Array
		for (int i = 0; i <= (center-leftBound); i++) {
			
			L[i] = this.arraySort[leftBound+i];
			
		}
		
		// Fill Right Array
		for (int i = 0; i < (rightBound-center); i++) {
			
			R[i] = this.arraySort[center+1+i];			
			
		}
		
		int rValue = 0;
		int lValue = 0;
		int arrSortedValue = leftBound;
		
		while (rValue < (rightBound-center) && lValue <= (center-leftBound)) {
		
			if (L[lValue].compareTo(R[rValue]) <= 0) { // Min Is In L
				
				this.arraySort[arrSortedValue] = L[lValue];
				
				lValue++;
				
				arrSortedValue++;
				
			} else { // Min Is In R
				
				this.arraySort[arrSortedValue] = R[rValue];
				
				rValue++;
				
				arrSortedValue++;
				
			}			
			
		}
		
		// Filling The Sorted Array With The R Remaining Items
		while (lValue <= (center-leftBound)) {
					
			this.arraySort[arrSortedValue] = L[lValue];
					
			lValue++;
					
			arrSortedValue++;
					
		}
				
		// Filling The Sorted Array With The R Remaining Items
		while (rValue < rightBound-center) {
			
			this.arraySort[arrSortedValue] = R[rValue];
						
			rValue++;
			
			arrSortedValue++;
			
		}
		
	}
	
	
	
	/**
	 *  Insertion Sort Implementation
	 *  
	 * @param leftBound Left Limit For The Range Of Array's Values To Sort
	 * @param rightBound Right Limit For The Range Of Array's Values To Sort
	 * 
	 */
	private void insertionSort (int leftBound, int rightBound) {
		
		T val;
		
		int j;
		
		for (int i = leftBound+1; i <= rightBound; i++) {
			
			val = this.arraySort[i];
			
			j = i - 1;
			
			while (j >= leftBound && this.arraySort[j].compareTo(val) >= 0) {
				
				
				this.arraySort[j+1] = this.arraySort[j];
				
				j--;
				
			}
			
			this.arraySort[j+1] = val;
			
		}
		
	}
	


	
}


